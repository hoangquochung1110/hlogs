<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Hung Hoang</title><link href="hunghoang/" rel="alternate"></link><link href="hunghoang/feeds/all.atom.xml" rel="self"></link><id>hunghoang/</id><updated>2021-11-30T10:00:00+07:00</updated><entry><title>Database Index</title><link href="hunghoang/database-index.html" rel="alternate"></link><published>2021-11-30T10:00:00+07:00</published><updated>2021-11-30T10:00:00+07:00</updated><author><name>Hung Hoang</name></author><id>tag:None,2021-11-30:hunghoang/database-index.html</id><summary type="html">&lt;p&gt;People is often said that indexing is a go-to technique to process efficiently queries in database. This post is for summarizing what database index is and revisiting hash and B+Tree.&lt;/p&gt;
&lt;p&gt;Index is a data structure that organizes records to optimize certain kinds of retrieval operations. We may create index …&lt;/p&gt;</summary><content type="html">&lt;p&gt;People is often said that indexing is a go-to technique to process efficiently queries in database. This post is for summarizing what database index is and revisiting hash and B+Tree.&lt;/p&gt;
&lt;p&gt;Index is a data structure that organizes records to optimize certain kinds of retrieval operations. We may create index on a field of the table then retrieve all records that satisfy search conditions on &lt;code&gt;search-key&lt;/code&gt; field. Without index, our query would end up scanning linearly the entire content of the table to fetch only one or a few records.&lt;/p&gt;
&lt;p&gt;In this post, I'd like to summarize the performance and use cases of two common indexing techniques: &lt;strong&gt;Hash index&lt;/strong&gt; and &lt;strong&gt;B+tree&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Hash index&lt;/h2&gt;
&lt;p&gt;This technique is widely used for creating indices in &lt;em&gt;main memory&lt;/em&gt; because its fast retrieval by nature. It has average O(1) operation complexity and O(n) storage complexity.
In many books, people use the term &lt;code&gt;bucket&lt;/code&gt; to denote a unit of storage that stores one or more records
There are two things to discuss when it comes to hashing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hash function: maps search keys (as its input) to an integer representing that key in the bucket.&lt;/li&gt;
&lt;li&gt;Hashing scheme: how to deal with key collision after hashing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="hash function" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/khkm46v11z8o3geabglx.png"&gt;&lt;/p&gt;
&lt;p&gt;Some people ask: why collision ? Does a &lt;a href="https://en.wikipedia.org/wiki/Perfect_hash_function"&gt;perfect hash function&lt;/a&gt; ever exist ? In fact, let's say your keys is an infinite set, it's impossible to map them into a set of 32-bit integers without having no collision. There should be a trade-off between computation and collision rate.&lt;/p&gt;
&lt;p&gt;There are a few hashing scheme worth mentioning: &lt;a href="https://en.wikipedia.org/wiki/Linear_probing#:~:text=Linear%20probing%20is%20a%20scheme,by%20Gene%20Amdahl%2C%20Elaine%20M."&gt;linear probing&lt;/a&gt;, &lt;a href="https://www.tutorialspoint.com/hashing-with-chaining-in-data-structure"&gt;chained hashing&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Extendible_hashing"&gt;extendible hashing&lt;/a&gt;. Lookup/insert/delete algorithms vary by hashing scheme, for example, chained hashing deal with key collisions by placing elements have the same hash value in the same bucket. &lt;/p&gt;
&lt;h3&gt;Pros&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hash index is suitable for equality or primary key lookup. Queries can benefit from hash index to get amortized O(1) lookup cost. For example: &lt;code&gt;SELECT name, id FROM student WHERE id = '1315';&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Cons&lt;/h3&gt;
&lt;p&gt;Hash table has some limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Range queries are not efficient. Hash table is based on uniform distribution. In other words, you have no control of where an index entry is going to be placed.&lt;/li&gt;
&lt;li&gt;Low scalability: performance of lookup operation can degrade when there a lot of collisions and it requires to resize the hash table then rehash existing index entries.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;B+Tree&lt;/h2&gt;
&lt;p&gt;This is a self-balancing tree data structure that keeps data in sorted order and allows fast search within each node, typically using binary search.
B+Tree is a standard index implementation in almost all relational database system.&lt;/p&gt;
&lt;p&gt;B+Tree is basically a M-way search tree that have the following structure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;perfectly balance: leaf nodes always have the same height.&lt;/li&gt;
&lt;li&gt;every inner node other than the root is at least half full (M/2 − 1 &amp;lt;= num of keys &amp;lt;= M − 1).&lt;/li&gt;
&lt;li&gt;every inner node with k keys has k+1 non-null children.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Every node of the tree has an array of sorted key-value pairs. The key-value pair is constructed from (search-key value, pointer) for root and inner nodes. Leaf node values can be 2 possibilities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the actual record&lt;/li&gt;
&lt;li&gt;the pointer to actual record&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Lookup a value &lt;em&gt;v&lt;/em&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Start with root node&lt;/li&gt;
&lt;li&gt;While node is not a leaf node, we do:&lt;ul&gt;
&lt;li&gt;Find the smallest Ki where Ki &amp;gt;= v&lt;/li&gt;
&lt;li&gt;If Ki == v: set current node to the node pointed by Pi+1&lt;/li&gt;
&lt;li&gt;Otherwise, set current node to node pointed by Pi&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Look up a key using B+Tree index" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xwhs1v0ck8o3ddoibfzw.png"&gt;&lt;/p&gt;
&lt;h3&gt;Duplicate keys&lt;/h3&gt;
&lt;p&gt;In general, search-key can be duplicate, to solve this, most database implementations come up with composite search key. For example, we want to create an index on &lt;code&gt;student_name&lt;/code&gt; then our composite search key should be (student_name, Ap) where Ap is the primary key of the table.&lt;/p&gt;
&lt;h3&gt;Pros&lt;/h3&gt;
&lt;p&gt;There're two major pros that B+tree offers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Minimizing I/O operations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reduced height: B+Tree has quite large &lt;a href="https://en.wikipedia.org/wiki/Branching_factor"&gt;branching factor&lt;/a&gt; which makes the tree fat and short. The figure below illustrates a B+Tree with height of 2. As we can see nodes are spread out, it takes fewer nodes to traverse down to a leaf. The cost of looking up a single value is the height of the tree + 1 for the random access to the table&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scalability:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have predictable performance for all cases, O(log(n)) in particular. For databases, it is usually more important than having better best or average case performance.&lt;/li&gt;
&lt;li&gt;The tree always remain balanced by its implementation. A B+Tree with n keys always has a depth of O(log(n)). Thus, the performance will not degrade if the database grows bigger. A four-level tree with a branching factor of 500 can store up to 256 TB provided that a page is size of 4KB.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Figure 2" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/k6colaz4amph93f1ikpq.gif"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+Tree is most suited for range queries, for example &lt;code&gt;"SELECT * FROM student WHERE age &amp;gt; 20 AND age &amp;lt; 22"&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Although hash index performs better in terms of exact match queries, B+Tree is arguably the most widely used index structure in RDBMS thanks to its consistent performance in overall and high scalability.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;&lt;/th&gt;
&lt;th align="center"&gt;B+Tree&lt;/th&gt;
&lt;th align="center"&gt;Hash&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Lookup Time&lt;/td&gt;
&lt;td align="center"&gt;O(log(n))&lt;/td&gt;
&lt;td align="center"&gt;O(log(1))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Insertion Time&lt;/td&gt;
&lt;td align="center"&gt;O(log(n))&lt;/td&gt;
&lt;td align="center"&gt;O(log(1))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Deletion Time&lt;/td&gt;
&lt;td align="center"&gt;O(log(n))&lt;/td&gt;
&lt;td align="center"&gt;O(log(1))&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Recently, the log-structured merge tree (LSM-tree) has attracted significant interest as a contender to B+-tree, because its data structure could enable better storage space usage efficiency. I'll investigate it further and make a post about it in the near future.&lt;/p&gt;</content><category term="Database"></category></entry></feed>