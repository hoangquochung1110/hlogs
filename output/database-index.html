<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
	<head>
		<link href="http://gmpg.org/xfn/11" rel="profile">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta http-equiv="content-type" content="text/html; charset=utf-8">

		<!-- Metadata -->
	<meta name="description" content="">
	<meta property="og:description" content="">
	<meta property="og:title" content="Database Index" />
	<meta property="og:type" content="article" />
	<meta property="og:url" content="/database-index.html" />
		<meta property="og:image" content="/images/profile.JPG" />

		<!-- Enable responsiveness on mobile devices-->
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

		<title>Hung Hoang</title>

		<!-- CSS -->
		<link href="//fonts.googleapis.com/" rel="dns-prefetch">
		<link href="//fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic|Abril+Fatface|PT+Sans:400,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet">

		<link rel="stylesheet" href="/theme/css/poole.css" />
		<link rel="stylesheet" href="/theme/css/hyde.css" />
		<link rel="stylesheet" href="/theme/css/syntax.css" />
			<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.1.7/css/fork-awesome.min.css" crossorigin="anonymous">

		<!-- Feeds -->

		<!-- Analytics -->
	</head>

	<body class="theme-base-0d">
<div class="sidebar">
	<div class="container sidebar-sticky">
		<div class="sidebar-about">

			<h1>
				<a href="/">
					<img class="profile-picture" src="/images/profile.JPG">
					Hung Hoang
				</a>
			</h1>
			<p class="lead"></p>
			<p class="lead"> </p>
			<p></p>
		</div>
			<ul class="sidebar-nav">
					<li><a href="/pages/about-me.html">About me</a></li>
			</ul>
		<nav class="sidebar-social">
					<a class="sidebar-social-item" href="#" target="_blank">
						<i class="fa fa-You can add links in your config file"></i>
					</a>
					<a class="sidebar-social-item" href="#" target="_blank">
						<i class="fa fa-Another social link"></i>
					</a>
			<a class="sidebar-social-item" href="/">
				<i class="fa fa-rss"></i>
			</a>
		</nav>
	</div>
</div>		<div class="content container">
<div class="post">
	<h1 class="post-title">Database Index</h1>
	<span class="post-date">Tue 30 November 2021</span>
	<p>People is often said that indexing is a go-to technique to process efficiently queries in database. This post is for summarizing what database index is and revisiting hash and B+Tree.</p>
<p>Index is a data structure that organizes data records on disk to optimize certain kinds of retrieval operations. We may create index on a field of the table then retrieve all records that satisfy search conditions on <code>search-key</code> field. Without index, our query would end up scanning linearly the entire content of the table to fetch only one or a few records.</p>
<p>Basic concepts/terms used in indexing like: <code>search-key</code>, <code>ordered-indices</code> or <code>hash-indices</code> can be found at <a href="https://www2.cs.sfu.ca/CourseCentral/354/zaiane/material/notes/Chapter11/node2.html">here</a></p>
<p>In this post, I'd like to summarize the performance and use cases of two common indexing techniques: <strong>Hash index</strong> and <strong>B+tree</strong></p>
<h2>Hash index</h2>
<p>This technique is widely used for creating indices in <em>main memory</em> because its fast retrieval by nature. It has average O(1) operation complexity and O(n) storage complexity.
In many books, people use the term <code>bucket</code> to denote a unit of storage that stores one or more records
There are two things to discuss when it comes to hashing:</p>
<ul>
<li>Hash function: maps search keys (as its input) to an integer representing that key in the bucket.</li>
<li>Hashing scheme: how to deal with key collision after hashing.</li>
</ul>
<p><img alt="hash function" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/khkm46v11z8o3geabglx.png"></p>
<p>Some people ask: why collision ? Does a <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">perfect hash function</a> ever exist ? In fact, let's say your keys is an infinite set, it's impossible to map them into a set of 32-bit integers without having no collision. There should be a trade-off between computation and collision rate.</p>
<p>There are a few hashing scheme worth mentioning: <a href="https://en.wikipedia.org/wiki/Linear_probing#:~:text=Linear%20probing%20is%20a%20scheme,by%20Gene%20Amdahl%2C%20Elaine%20M.">linear probing</a>, <a href="https://www.tutorialspoint.com/hashing-with-chaining-in-data-structure">chained hashing</a> and <a href="https://en.wikipedia.org/wiki/Extendible_hashing">extendible hashing</a>. Lookup/insert/delete algorithms vary by hashing scheme, for example, chained hashing deal with key collisions by placing elements have the same hash value in the same bucket. </p>
<h3>Pros</h3>
<ul>
<li>Hash index is suitable for equality or primary key lookup. Queries can benefit from hash index to get amortized O(1) lookup cost. For example: <code>SELECT name, id FROM student WHERE id = '1315';</code></li>
</ul>
<h3>Cons</h3>
<p>Hash table has some limitations:</p>
<ul>
<li>Range queries are not efficient. Hash table is based on uniform distribution. In other words, you have no control of where an index entry is going to be placed.</li>
<li>Low scalability: performance of lookup operation can degrade when there a lot of collisions and it requires to resize the hash table then rehash existing index entries.</li>
</ul>
<h2>B+Tree</h2>
<p>This is a self-balancing tree data structure that keeps data in sorted order and allows fast search within each node, typically using binary search.
B+Tree is a standard index implementation in almost all relational database system.</p>
<p>B+Tree is basically a M-way search tree that have the following structure:</p>
<ul>
<li>perfectly balance: leaf nodes have the same height.</li>
<li>every inner node other than the root is at least half full (M/2 − 1 &lt;= num of keys &lt;= M − 1).</li>
<li>every inner node with k keys has k+1 non-null children.</li>
</ul>
<p>Every node of the tree has an array of sorted key-value pairs. The key-value pair is constructed from (search-key value, pointer) for root and inner nodes. Leaf node values can be 2 possibilities:</p>
<ul>
<li>the actual record</li>
<li>the pointer to actual record</li>
</ul>
<h3>Lookup a value <em>v</em></h3>
<ul>
<li>Start with root node</li>
<li>While node is not a leaf node, we do:<ul>
<li>Find the smallest Ki where Ki &gt;= v</li>
<li>If Ki == v: set current node to the node pointed by Pi+1</li>
<li>Otherwise, set current node to node pointed by Pi</li>
</ul>
</li>
</ul>
<p><img alt="Look up a key using B+Tree index" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xwhs1v0ck8o3ddoibfzw.png"></p>
<h3>Duplicate keys</h3>
<p>In general, search-key can be duplicate, to solve this, most database implementations come up with composite search key. For example, we want to create an index on <code>student_name</code> then our composite search key should be (student_name, Ap) where Ap is the primary key of the table.</p>
<h3>Pros</h3>
<p>There're two major pros that B+tree offers:</p>
<ul>
<li>
<p>Minimizing I/O operations which is real deal since I/O accesses are expensive. A reason for this advantage:</p>
<ul>
<li>Reduced height: B+Tree has quite large <a href="https://en.wikipedia.org/wiki/Branching_factor">branching factor</a> which makes the tree fat and short. The figure below illustrates a B+Tree with height of 2. As we can see nodes are spread out, it takes fewer nodes, less disk-access to traverse down to a leaf.</li>
</ul>
</li>
<li>
<p>Scalability:</p>
<ul>
<li>You have predictable performance for all cases, O(log(n)) in particular. For databases, it is usually more important than having better best or average case performance.</li>
<li>The tree always remain balanced by its implementation. A B+Tree with n keys always has a depth of O(log(n)). Thus, the performance will not degrade if the database grows bigger. A four-level tree with a branching factor of 500 can store up to 256 TB provided that a page is size of 4KB.</li>
</ul>
</li>
</ul>
<p><img alt="Figure 2" src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/k6colaz4amph93f1ikpq.gif"></p>
<ul>
<li>B+Tree is most suited for range queries, for example <code>"SELECT * FROM student WHERE age &gt; 20 AND age &lt; 22"</code></li>
</ul>
<h2>Conclusion</h2>
<p>Although hash index performs better in terms of exact match queries, B+Tree is arguably the most widely used index structure in RDBMS thanks to its consistent performance in overall and high scalability.</p>
<p>Recently, the log-structured merge tree (LSM-tree) has attracted significant interest as a contender to B+-tree, because its data structure could enable better storage space usage efficiency.</p>


</div>
		</div>
	</body>
</html>